<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <title> channel数据结构 · 诺唯 </title>
    <meta charset="UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=edge, chrome=1" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>
<meta name="browsermode" content="application">
<meta name="apple-mobile-web-app-capable" content="yes">
<meta name="apple-mobile-web-app-title" content="诺唯">
<meta name="apple-mobile-web-app-status-bar-style" content="default">
<meta name="msapplication-navbutton-color" content="#666666">
<meta name= "format-detection" content="telephone=no" />
<meta name="keywords" content="nlvi, Nlvi" />


    <meta name="subtitle" content="Noaway">


    <meta name="description" content="诺唯,noaway">



    <meta name="keywords" content="Go 语言, golang 最佳实践, 技术原理, Nlvi" />

<link rel="stylesheet" href="/style/style.css">
<script src="/script/jquery.min.js"></script>
<script>
    var CONFIG = {
        title: "诺唯",
        author: "王阳",
        lightbox: true,
        animate: true
    }
</script>



    <link rel="stylesheet" href="/lightbox/css/lightbox.min.css">




    <link rel="stylesheet" href="/syuanpi/syuanpi.min.css">









    <script async src="//dn-lbstatics.qbox.me/busuanzi/2.3/busuanzi.pure.mini.js"></script>


</head>
<body>
    <div class="progress">
    <div class="progress-inner"></div>
</div>
    <div class="body">
    <div class="tagcloud-mask"></div>  
<div class="tagcloud" id="tagcloud">
    <div class="tagcloud-inner">
        <a href="/tags/Go-语言/" style="font-size: 14px;">Go 语言</a> <a href="/tags/Go语言/" style="font-size: 14px;">Go语言</a> <a href="/tags/IO多路复用/" style="font-size: 14px;">IO多路复用</a> <a href="/tags/epoll/" style="font-size: 14px;">epoll</a> <a href="/tags/golang-最佳实践/" style="font-size: 14px;">golang 最佳实践</a> <a href="/tags/技术原理/" style="font-size: 14px;">技术原理</a> <a href="/tags/编程/" style="font-size: 14px;">编程</a>
    </div>
</div>
    <header class="header" id="header">
    <div class="title syuanpi tvIn">
    <div class="table">
        <div class="connect">
            <div class="connect-inner">
                <span><a href="/">诺唯</a></span>
                
                    <span id="subtitle">Noaway</span>
                
            </div>
        </div>
    </div>
</div>
    <nav class="main-nav syuanpi tvIn">
<div class="table">

    <ul class="menu">
        
        <li class="menu-item">
            <a href="javascript:;" id="search">
                <span>搜索</span>
                
                    <span class="menu-item-label">search</span>
                
            </a>
        </li>
        
        
        
            <li class="menu-item">
                <a href="/">
                    <span>文章</span>
                    
                        <span class="menu-item-label">article</span>
                    
                </a>
            </li>
        
        
        
            <li class="menu-item">
                <a href="/archives">
                    <span>归档</span>
                    
                        <span class="menu-item-label">archives</span>
                    
                </a>
            </li>
        
        
        
            <li class="menu-item">
                <a href="javascript:;" id="tags">
                    <span>标签</span>
                    
                        <span class="menu-item-label">tags</span>
                    
                </a>
            </li>
        
        
        
            <li class="menu-item">
                <a href="/about">
                    <span>关于</span>
                    
                        <span class="menu-item-label">about</span>
                    
                </a>
            </li>
        
        
    </ul>

</div>
</nav>
</header>
<div class="mobile-header">
    <div class="mobile-header-body">
        <div class="mobile-header-list">
            
            
                <div class="mobile-nav-item">
                    <a href="/">
                        <span>文章</span>
                        
                            <span class="menu-item-label">article</span>
                        
                    </a>
                </div>
            
            
            
                <div class="mobile-nav-item">
                    <a href="/archives">
                        <span>归档</span>
                        
                            <span class="menu-item-label">archives</span>
                        
                    </a>
                </div>
            
            
            
                <div class="mobile-nav-item inner-cloud">
                    <div class="mobile-nav-tag">
                        <a href="javascript:;" id="mobile-tags">
                            <span>标签</span>
                            
                                <span class="menu-item-label">tags</span>
                            
                        </a>
                    </div>
                    <div class="mobile-nav-tagcloud">
                        <div class="mobile-tagcloud-inner">
                            <a href="/tags/Go-语言/" style="font-size: 14px;">Go 语言</a> <a href="/tags/Go语言/" style="font-size: 14px;">Go语言</a> <a href="/tags/IO多路复用/" style="font-size: 14px;">IO多路复用</a> <a href="/tags/epoll/" style="font-size: 14px;">epoll</a> <a href="/tags/golang-最佳实践/" style="font-size: 14px;">golang 最佳实践</a> <a href="/tags/技术原理/" style="font-size: 14px;">技术原理</a> <a href="/tags/编程/" style="font-size: 14px;">编程</a>
                        </div>
                    </div>
                </div>
            
            
            
                <div class="mobile-nav-item">
                    <a href="/about">
                        <span>关于</span>
                        
                            <span class="menu-item-label">about</span>
                        
                    </a>
                </div>
            
            
        </div>
    </div>
    <div class="mobile-header-nav">
        <div class="mobile-header-item" id="mobile-left">
            <div class="header-menu-item">
                <span class="header-menu-line"></span>
            </div>
        </div>
        <h1 class="mobile-header-title">
            <a href="/">诺唯</a>
        </h1>
        <div class="mobile-header-item"></div>
    </div>
</div>

    <div class="container">
        <main class="main" id="main">
            
    
    <article class="post">
        <header class="post-header">
            <div class="post-time syuanpi riseIn-light back-1">
                <span>2017年10月26日</span>
                
            </div>
            <h1 class="post-title syuanpi riseIn-light back-2">
            
                channel数据结构
            
            </h1>
            
                
                    <div class="post-tags syuanpi riseIn-light back-3">
                    
                        <a href="/tags/Go-语言/">Go 语言</a>
                    
                        <a href="/tags/golang-最佳实践/">golang 最佳实践</a>
                    
                        <a href="/tags/技术原理/">技术原理</a>
                    
                    </div>
                
            
        </header>
        <div class="post-content syuanpi riseIn-light back-3">
            
                <p><img src="http://oyft9mgwt.bkt.clouddn.com/channel%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84.jpg" alt=""></p>
<p>channel是go语言的一大特色，使用原子函数还是使用互斥锁都不如使用channel来的简单，go语言中的channel可以作为函数参数传递和返回值返回，通过发送和接受数据在goroutine之间同步(在学习和使用go语言的时候，我们应该牢记，go语言中所有的结构都是值拷贝的)<br>本文不对channel使用作讲解，直接上酸(dai)菜(ma):</p>
<p>type hchan struct {<br>    qcount   uint           //队列数据总的数据数量<br>    dataqsiz uint           //环形队列的数据大小<br>    buf      unsafe.Pointer //指向dataqsiz元素类型大小的数组<br>    elemsize uint16<br>    closed   uint32<br>    elemtype <em>_type // 元素类型<br>    sendx    uint   // 发送数据时的游标<br>    recvx    uint   // 接收数据时的游标<br>    recvq    waitq  // 接收而阻塞的等待队列<br>    sendq    waitq  // 发送而阻塞的等待队列<br>        lock mutex      // 保护hchan所有字段的锁<br>}<br>hchan 是chan的结构体，在hchan结构中qcount和elemsize指定队列的容量和使用量，dataqsiz队列的大小，整个hchan结构体只记录了队列大小相关的值，带有缓冲区的chan需要make的时候指定，我们简单的看一下chan的make方法是如何分配缓冲区的<br>func makechan(t </em>chantype, size int64) *hchan {<br>    elem := t.elem</p>
<pre><code>    ...
    ...

var c *hchan
if elem.kind&amp;kindNoPointers != 0 || size == 0 {
    c = (*hchan)(mallocgc(hchanSize+uintptr(size)*elem.size, nil, true))
    if size &gt; 0 &amp;&amp; elem.size != 0 {
        c.buf = add(unsafe.Pointer(c), hchanSize)
    } else {
        c.buf = unsafe.Pointer(c)
    }
} else {
    c = new(hchan)
    c.buf = newarray(elem, int(size))
}
...
    ...
</code></pre><p>}<br>makechan 将hchan初始化0值之后并判断size如果是有缓冲区的chan则紧挨着hchan结构体中分配size大小的 “_type” 类型的数组。</p>
<p>type waitq struct {<br>    first <em>sudog<br>    last  </em>sudog<br>}<br>type sudog struct {<br>    g          <em>g<br>    selectdone </em>uint32<br>    next       <em>sudog<br>    prev       </em>sudog<br>    elem       unsafe.Pointer </p>
<pre><code>acquiretime int64
releasetime int64
ticket      uint32
waitlink    *sudog // g.waiting list
c           *hchan // channel
</code></pre><p>}<br>g和elem分别存储goroutine的数据</p>
<p>发送channel<br>向channel中写数据时在runtime包中对应的是，以下方法：</p>
<p>func chansend(t <em>chantype, c </em>hchan, ep unsafe.Pointer, block bool, callerpc uintptr) bool {<br>    if raceenabled {<br>        raceReadObjectPC(t.elem, ep, callerpc, funcPC(chansend))<br>    }<br>    if msanenabled {<br>        msanread(ep, t.elem.size)<br>    }</p>
<pre><code>if c == nil {
    if !block {
        return false
    }
    gopark(nil, nil, &quot;chan send (nil chan)&quot;, traceEvGoStop, 2)
    throw(&quot;unreachable&quot;)
}

if debugChan {
    print(&quot;chansend: chan=&quot;, c, &quot;\n&quot;)
}

if raceenabled {
    racereadpc(unsafe.Pointer(c), callerpc, funcPC(chansend))
}


if !block &amp;&amp; c.closed == 0 &amp;&amp; ((c.dataqsiz == 0 &amp;&amp; c.recvq.first == nil) ||
    (c.dataqsiz &gt; 0 &amp;&amp; c.qcount == c.dataqsiz)) {
    return false
}

var t0 int64
if blockprofilerate &gt; 0 {
    t0 = cputicks()
}

lock(&amp;c.lock)

if c.closed != 0 {
    unlock(&amp;c.lock)
    panic(plainError(&quot;send on closed channel&quot;))
}

if sg := c.recvq.dequeue(); sg != nil {
    send(c, sg, ep, func() { unlock(&amp;c.lock) })
    return true
}

if c.qcount &lt; c.dataqsiz {
    qp := chanbuf(c, c.sendx)
    if raceenabled {
        raceacquire(qp)
        racerelease(qp)
    }
    typedmemmove(c.elemtype, qp, ep)
    c.sendx++
    if c.sendx == c.dataqsiz {
        c.sendx = 0
    }
    c.qcount++
    unlock(&amp;c.lock)
    return true
}

if !block {
    unlock(&amp;c.lock)
    return false
}

gp := getg()
mysg := acquireSudog()
mysg.releasetime = 0
if t0 != 0 {
    mysg.releasetime = -1
}

mysg.elem = ep
mysg.waitlink = nil
mysg.g = gp
mysg.selectdone = nil
mysg.c = c
gp.waiting = mysg
gp.param = nil
c.sendq.enqueue(mysg)
goparkunlock(&amp;c.lock, &quot;chan send&quot;, traceEvGoBlockSend, 3)


if mysg != gp.waiting {
    throw(&quot;G waiting list is corrupted&quot;)
}
gp.waiting = nil
if gp.param == nil {
    if c.closed == 0 {
        throw(&quot;chansend: spurious wakeup&quot;)
    }
    panic(plainError(&quot;send on closed channel&quot;))
}
gp.param = nil
if mysg.releasetime &gt; 0 {
    blockevent(mysg.releasetime-t0, 2)
}
mysg.c = nil
releaseSudog(mysg)
return true
</code></pre><p>}<br>发送数据时先判断channel类型，如果有缓冲区，判断channel是否还有空间，然后从等待channel中获取等待channel中的接受者，如果取到接收者，则将对象直接传递给接受者，然后将接受者所在的go放入P所在的可运行G队列,发送过程完成，如果未取到接收者，则将发送者enqueue到发送channel，发送者进入阻塞状态，有缓冲的channel需要先判断channel缓冲是否还有空间，如果缓冲空间已满，则将发送者enqueue到发送channel，发送者进入阻塞状态如果缓冲空间未满，则将元素copy到缓冲中，这时发送者就不会进入阻塞状态，最后尝试唤醒等待队列中的一个接受者。</p>
<p>接收channel<br>向channel中接收数据时在runtime包中对应的是，以下方法：</p>
<p>func chanrecv(t <em>chantype, c </em>hchan, ep unsafe.Pointer, block bool) (selected, received bool) {<br>    // raceenabled: don’t need to check ep, as it is always on the stack<br>    // or is new memory allocated by reflect.</p>
<pre><code>if debugChan {
    print(&quot;chanrecv: chan=&quot;, c, &quot;\n&quot;)
}

if c == nil {
    if !block {
        return
    }
    gopark(nil, nil, &quot;chan receive (nil chan)&quot;, traceEvGoStop, 2)
    throw(&quot;unreachable&quot;)
}

// Fast path: check for failed non-blocking operation without acquiring the lock.
//
// After observing that the channel is not ready for receiving, we observe that the
// channel is not closed. Each of these observations is a single word-sized read
// (first c.sendq.first or c.qcount, and second c.closed).
// Because a channel cannot be reopened, the later observation of the channel
// being not closed implies that it was also not closed at the moment of the
// first observation. We behave as if we observed the channel at that moment
// and report that the receive cannot proceed.
//
// The order of operations is important here: reversing the operations can lead to
// incorrect behavior when racing with a close.
if !block &amp;&amp; (c.dataqsiz == 0 &amp;&amp; c.sendq.first == nil ||
    c.dataqsiz &gt; 0 &amp;&amp; atomic.Loaduint(&amp;c.qcount) == 0) &amp;&amp;
    atomic.Load(&amp;c.closed) == 0 {
    return
}

var t0 int64
if blockprofilerate &gt; 0 {
    t0 = cputicks()
}

lock(&amp;c.lock)

if c.closed != 0 &amp;&amp; c.qcount == 0 {
    if raceenabled {
        raceacquire(unsafe.Pointer(c))
    }
    unlock(&amp;c.lock)
    if ep != nil {
        typedmemclr(c.elemtype, ep)
    }
    return true, false
}

if sg := c.sendq.dequeue(); sg != nil {
    // Found a waiting sender. If buffer is size 0, receive value
    // directly from sender. Otherwise, receive from head of queue
    // and add sender&apos;s value to the tail of the queue (both map to
    // the same buffer slot because the queue is full).
    recv(c, sg, ep, func() { unlock(&amp;c.lock) })
    return true, true
}

if c.qcount &gt; 0 {
    // Receive directly from queue
    qp := chanbuf(c, c.recvx)
    if raceenabled {
        raceacquire(qp)
        racerelease(qp)
    }
    if ep != nil {
        typedmemmove(c.elemtype, ep, qp)
    }
    typedmemclr(c.elemtype, qp)
    c.recvx++
    if c.recvx == c.dataqsiz {
        c.recvx = 0
    }
    c.qcount--
    unlock(&amp;c.lock)
    return true, true
}

if !block {
    unlock(&amp;c.lock)
    return false, false
}

// no sender available: block on this channel.
gp := getg()
mysg := acquireSudog()
mysg.releasetime = 0
if t0 != 0 {
    mysg.releasetime = -1
}
// No stack splits between assigning elem and enqueuing mysg
// on gp.waiting where copystack can find it.
mysg.elem = ep
mysg.waitlink = nil
gp.waiting = mysg
mysg.g = gp
mysg.selectdone = nil
mysg.c = c
gp.param = nil
c.recvq.enqueue(mysg)
goparkunlock(&amp;c.lock, &quot;chan receive&quot;, traceEvGoBlockRecv, 3)

// someone woke us up
if mysg != gp.waiting {
    throw(&quot;G waiting list is corrupted&quot;)
}
gp.waiting = nil
if mysg.releasetime &gt; 0 {
    blockevent(mysg.releasetime-t0, 2)
}
closed := gp.param == nil
gp.param = nil
mysg.c = nil
releaseSudog(mysg)
return true, !closed
</code></pre><p>}<br>接收channel与发送类似首先也是判断channel的类型，然后如果是有缓冲的channel就判断缓冲中是否有元素，接着从channel中获取接受者，如果取到，则直接从接收者获取元素，并唤醒发送者，本次接收过程完成，如果没有取到接收者，阻塞当前的goroutine并等待发送者唤醒，如果是拥有缓冲的channel需要先判断缓冲中是否有元素，缓冲为空时，阻塞当前goroutine并等待发送者唤醒，缓冲如果不为空，则取出缓冲中的第一个元素，然后尝试唤醒channel中的一个发送者(这篇文章暂属临时版本，有些话需要斟酌，不久会更新。。。)</p>
<p>接下来我会发表select的结构先说个预告。。。</p>
<p>select {<br>       case c &lt;- v:<br>              … foo<br>       default:<br>              … bar<br>}</p>
<p>//select的case和default 编译器最终会编译成if else</p>
<p>if selectnbsend(c, v) {<br>       … foo<br>} else {<br>       … bar<br>}<br>未来几天我会完成select的具体实现。。。</p>

            
        
        </div>
        
            
            
        
    </article>
    
        
    <nav class="article-page">
        
        
            <a href="/2017/10/26/interface引发的事件真相/" id="art-right" class="art-left">
                <span class="prev-title"> 
                    <i class="iconfont icon-left"></i>interface引发的事件真相
                </span>
            </a>
        
    </nav>

        
    <i id="com-switch" class="iconfont icon-more jumping-in long infinite" style="font-size:24px;display:block;text-align:center;transform:rotate(180deg);"></i>
    <div class="post-comments" id="post-comments" style="display: block;margin: auto 16px;">
        
        
        
        
<div id="disqus_thread"></div>
<script>

/**
*  RECOMMENDED CONFIGURATION VARIABLES: EDIT AND UNCOMMENT THE SECTION BELOW TO INSERT DYNAMIC VALUES FROM YOUR PLATFORM OR CMS.
*  LEARN WHY DEFINING THESE VARIABLES IS IMPORTANT: https://disqus.com/admin/universalcode/#configuration-variables*/
/*
var disqus_config = function () {
this.page.url = PAGE_URL;  // Replace PAGE_URL with your page's canonical URL variable
this.page.identifier = PAGE_IDENTIFIER; // Replace PAGE_IDENTIFIER with your page's unique identifier variable
};
*/
(function() { // DON'T EDIT BELOW THIS LINE
var d = document, s = d.createElement('script');
s.src = 'https://blog-noaway-io.disqus.com/embed.js';
s.setAttribute('data-timestamp', +new Date());
(d.head || d.body).appendChild(s);
})();
</script>
<noscript>Please enable JavaScript to view the <a href="https://disqus.com/?ref_noscript">comments powered by Disqus.</a></noscript>
                            


    </div>



    


        </main>
        <footer class="footer syuanpi fadeIn" id="footer">
    <hr>
    <div class="footer-wrapper">
        <div class="left">
            <div class="contact-icon">
    
    
    
    
    
    
    
    
        
        
        
        
            <a href="https://www.zhihu.com/people/noaway" class="iconfont icon-zhihu" title="zhihu"></a>
        
        
        
        
    
        
            <a href="https://github.com/noaway" class="iconfont icon-github" title="github"></a>
        
        
        
        
        
        
        
    
</div>
        </div>
        <div class="right">
            <div class="copyright">
    <div class="info">
        <span>&copy;</span>
        <span>2016 ~ 2017</span>
        <span>❤</span>
        <span>王阳</span>
    </div>
    
    
    <div class="visit_count">
        <i class="iconfont icon-visit"></i>
        <span id="busuanzi_value_site_uv"></span>
        <i class="iconfont icon-people"></i>
        <span id="busuanzi_value_site_pv"></span>
    </div>
    
</div>
        </div>
    </div>
</footer>
    </div>
    <script src="/script/nlvi.js"></script>
<script src="/script/search.js"></script>

    <script src="/lightbox/js/lightbox.min.js"></script>

<script>
$(document).ready(function(){
    document.body.addEventListener('touchstart', function () {});
    $('.progress').hide();
    $('.body').show();
    Nlvi.tagcloud();
    Nlvi.mobileHeader();
    Nlvi.back2top();
    Nlvi.smoothScroll();
    Nlvi.onView();
    Nlvi.showToc();
    Nlvi.showComments();
    Nlvi.showReward();
    Nlvi.picPos();

    !CONFIG.animate && Nlvi.offAnimate();
    CONFIG.lightbox && Nlvi.onPicBox();
})
</script>
    </div>
    
        
    <div class="post-toc">
        <span class="title">文章目录</span>
        <div class="toc-inner syuanpi back-1 fallIn-light">
            <li class="title-link"><a href="javascript:;" class="toTop">channel数据结构</a></li>
            
        </div>
    </div>

    
    <div class="backtop syuanpi dead toTop" id="backtop">
    <i class="iconfont icon-up"></i>
    <span style="text-align:center;font-family:Georgia;"><span style="font-family:Georgia;" id="scrollpercent">1</span>%</span>
</div>
    
    <div class="search" id="search">
        <div class="mask" id="mask"></div>
        <div class="search-wrapper syuanpi">
            <h1 id="search-header" class="syuanpi">搜索一下？</h1>
            <div class="input">
                <input type="text" id="local-search-input" results="0" name="">
            </div>
            <div id="local-search-result"></div>
        </div>
    </div>
    <script>
    var GREETING = {
        morning: "当我们探索时，就要发现到真理",
        noon: "人的天职在于勇于探索真理。",
        after: "一件事实是一条没有性别的真理",
        night: "真理有时可能变得黯淡，但它永远不会熄灭",
        midnight: "真理在人那里获得生命力，并且展现出来"
    }
    $(document).ready(function(){
        Nlvi.search();
    });
    </script>

</body>
</html>
