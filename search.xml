<?xml version="1.0" encoding="utf-8"?>
<search> 
  
    
    <entry>
      <title><![CDATA[channel数据结构]]></title>
      <url>/2017/10/26/channel%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/</url>
      <content type="html"><![CDATA[<p><img src="http://oyft9mgwt.bkt.clouddn.com/channel%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84.jpg" alt=""></p>
<p>channel是go语言的一大特色，使用原子函数还是使用互斥锁都不如使用channel来的简单，go语言中的channel可以作为函数参数传递和返回值返回，通过发送和接受数据在goroutine之间同步(在学习和使用go语言的时候，我们应该牢记，go语言中所有的结构都是值拷贝的)<br>本文不对channel使用作讲解，直接上酸(dai)菜(ma):<br><a id="more"></a></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line">type hchan struct &#123;</div><div class="line">	qcount   uint           //队列数据总的数据数量</div><div class="line">	dataqsiz uint           //环形队列的数据大小 </div><div class="line">	buf      unsafe.Pointer //指向dataqsiz元素类型大小的数组</div><div class="line">	elemsize uint16</div><div class="line">	closed   uint32</div><div class="line">	elemtype *_type // 元素类型</div><div class="line">	sendx    uint   // 发送数据时的游标</div><div class="line">	recvx    uint   // 接收数据时的游标</div><div class="line">	recvq    waitq  // 接收而阻塞的等待队列</div><div class="line">	sendq    waitq  // 发送而阻塞的等待队列</div><div class="line">        lock mutex      // 保护hchan所有字段的锁</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>hchan 是chan的结构体，在hchan结构中qcount和elemsize指定队列的容量和使用量，dataqsiz队列的大小，整个hchan结构体只记录了队列大小相关的值，带有缓冲区的chan需要make的时候指定，我们简单的看一下chan的make方法是如何分配缓冲区的<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div></pre></td><td class="code"><pre><div class="line">func makechan(t *chantype, size int64) *hchan &#123;</div><div class="line">	elem := t.elem</div><div class="line">	</div><div class="line">        ...</div><div class="line">        ...</div><div class="line"></div><div class="line">	var c *hchan</div><div class="line">	if elem.kind&amp;kindNoPointers != 0 || size == 0 &#123;</div><div class="line">		c = (*hchan)(mallocgc(hchanSize+uintptr(size)*elem.size, nil, true))</div><div class="line">		if size &gt; 0 &amp;&amp; elem.size != 0 &#123;</div><div class="line">			c.buf = add(unsafe.Pointer(c), hchanSize)</div><div class="line">		&#125; else &#123;</div><div class="line">			c.buf = unsafe.Pointer(c)</div><div class="line">		&#125;</div><div class="line">	&#125; else &#123;</div><div class="line">		c = new(hchan)</div><div class="line">		c.buf = newarray(elem, int(size))</div><div class="line">	&#125;</div><div class="line">	...</div><div class="line">        ...</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>makechan 将hchan初始化0值之后并判断size如果是有缓冲区的chan则紧挨着hchan结构体中分配size大小的 “_type” 类型的数组。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line">type waitq struct &#123;</div><div class="line">	first *sudog</div><div class="line">	last  *sudog</div><div class="line">&#125;</div><div class="line">type sudog struct &#123;</div><div class="line">	g          *g</div><div class="line">	selectdone *uint32 </div><div class="line">	next       *sudog</div><div class="line">	prev       *sudog</div><div class="line">	elem       unsafe.Pointer </div><div class="line"></div><div class="line">	acquiretime int64</div><div class="line">	releasetime int64</div><div class="line">	ticket      uint32</div><div class="line">	waitlink    *sudog // g.waiting list</div><div class="line">	c           *hchan // channel</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>g和elem分别存储goroutine的数据</p>
<p>发送channel<br>向channel中写数据时在runtime包中对应的是，以下方法：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div><div class="line">85</div><div class="line">86</div><div class="line">87</div><div class="line">88</div><div class="line">89</div><div class="line">90</div><div class="line">91</div><div class="line">92</div><div class="line">93</div><div class="line">94</div><div class="line">95</div><div class="line">96</div><div class="line">97</div><div class="line">98</div><div class="line">99</div><div class="line">100</div><div class="line">101</div><div class="line">102</div><div class="line">103</div><div class="line">104</div></pre></td><td class="code"><pre><div class="line">func chansend(t *chantype, c *hchan, ep unsafe.Pointer, block bool, callerpc uintptr) bool &#123;</div><div class="line">	if raceenabled &#123;</div><div class="line">		raceReadObjectPC(t.elem, ep, callerpc, funcPC(chansend))</div><div class="line">	&#125;</div><div class="line">	if msanenabled &#123;</div><div class="line">		msanread(ep, t.elem.size)</div><div class="line">	&#125;</div><div class="line"></div><div class="line">	if c == nil &#123;</div><div class="line">		if !block &#123;</div><div class="line">			return false</div><div class="line">		&#125;</div><div class="line">		gopark(nil, nil, &quot;chan send (nil chan)&quot;, traceEvGoStop, 2)</div><div class="line">		throw(&quot;unreachable&quot;)</div><div class="line">	&#125;</div><div class="line"></div><div class="line">	if debugChan &#123;</div><div class="line">		print(&quot;chansend: chan=&quot;, c, &quot;\n&quot;)</div><div class="line">	&#125;</div><div class="line"></div><div class="line">	if raceenabled &#123;</div><div class="line">		racereadpc(unsafe.Pointer(c), callerpc, funcPC(chansend))</div><div class="line">	&#125;</div><div class="line"></div><div class="line">	</div><div class="line">	if !block &amp;&amp; c.closed == 0 &amp;&amp; ((c.dataqsiz == 0 &amp;&amp; c.recvq.first == nil) ||</div><div class="line">		(c.dataqsiz &gt; 0 &amp;&amp; c.qcount == c.dataqsiz)) &#123;</div><div class="line">		return false</div><div class="line">	&#125;</div><div class="line"></div><div class="line">	var t0 int64</div><div class="line">	if blockprofilerate &gt; 0 &#123;</div><div class="line">		t0 = cputicks()</div><div class="line">	&#125;</div><div class="line"></div><div class="line">	lock(&amp;c.lock)</div><div class="line"></div><div class="line">	if c.closed != 0 &#123;</div><div class="line">		unlock(&amp;c.lock)</div><div class="line">		panic(plainError(&quot;send on closed channel&quot;))</div><div class="line">	&#125;</div><div class="line"></div><div class="line">	if sg := c.recvq.dequeue(); sg != nil &#123;</div><div class="line">		send(c, sg, ep, func() &#123; unlock(&amp;c.lock) &#125;)</div><div class="line">		return true</div><div class="line">	&#125;</div><div class="line"></div><div class="line">	if c.qcount &lt; c.dataqsiz &#123;</div><div class="line">		qp := chanbuf(c, c.sendx)</div><div class="line">		if raceenabled &#123;</div><div class="line">			raceacquire(qp)</div><div class="line">			racerelease(qp)</div><div class="line">		&#125;</div><div class="line">		typedmemmove(c.elemtype, qp, ep)</div><div class="line">		c.sendx++</div><div class="line">		if c.sendx == c.dataqsiz &#123;</div><div class="line">			c.sendx = 0</div><div class="line">		&#125;</div><div class="line">		c.qcount++</div><div class="line">		unlock(&amp;c.lock)</div><div class="line">		return true</div><div class="line">	&#125;</div><div class="line"></div><div class="line">	if !block &#123;</div><div class="line">		unlock(&amp;c.lock)</div><div class="line">		return false</div><div class="line">	&#125;</div><div class="line"></div><div class="line">	gp := getg()</div><div class="line">	mysg := acquireSudog()</div><div class="line">	mysg.releasetime = 0</div><div class="line">	if t0 != 0 &#123;</div><div class="line">		mysg.releasetime = -1</div><div class="line">	&#125;</div><div class="line">	</div><div class="line">	mysg.elem = ep</div><div class="line">	mysg.waitlink = nil</div><div class="line">	mysg.g = gp</div><div class="line">	mysg.selectdone = nil</div><div class="line">	mysg.c = c</div><div class="line">	gp.waiting = mysg</div><div class="line">	gp.param = nil</div><div class="line">	c.sendq.enqueue(mysg)</div><div class="line">	goparkunlock(&amp;c.lock, &quot;chan send&quot;, traceEvGoBlockSend, 3)</div><div class="line"></div><div class="line">	</div><div class="line">	if mysg != gp.waiting &#123;</div><div class="line">		throw(&quot;G waiting list is corrupted&quot;)</div><div class="line">	&#125;</div><div class="line">	gp.waiting = nil</div><div class="line">	if gp.param == nil &#123;</div><div class="line">		if c.closed == 0 &#123;</div><div class="line">			throw(&quot;chansend: spurious wakeup&quot;)</div><div class="line">		&#125;</div><div class="line">		panic(plainError(&quot;send on closed channel&quot;))</div><div class="line">	&#125;</div><div class="line">	gp.param = nil</div><div class="line">	if mysg.releasetime &gt; 0 &#123;</div><div class="line">		blockevent(mysg.releasetime-t0, 2)</div><div class="line">	&#125;</div><div class="line">	mysg.c = nil</div><div class="line">	releaseSudog(mysg)</div><div class="line">	return true</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>发送数据时先判断channel类型，如果有缓冲区，判断channel是否还有空间，然后从等待channel中获取等待channel中的接受者，如果取到接收者，则将对象直接传递给接受者，然后将接受者所在的go放入P所在的可运行G队列,发送过程完成，如果未取到接收者，则将发送者enqueue到发送channel，发送者进入阻塞状态，有缓冲的channel需要先判断channel缓冲是否还有空间，如果缓冲空间已满，则将发送者enqueue到发送channel，发送者进入阻塞状态如果缓冲空间未满，则将元素copy到缓冲中，这时发送者就不会进入阻塞状态，最后尝试唤醒等待队列中的一个接受者。</p>
<p>接收channel<br>向channel中接收数据时在runtime包中对应的是，以下方法：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div><div class="line">85</div><div class="line">86</div><div class="line">87</div><div class="line">88</div><div class="line">89</div><div class="line">90</div><div class="line">91</div><div class="line">92</div><div class="line">93</div><div class="line">94</div><div class="line">95</div><div class="line">96</div><div class="line">97</div><div class="line">98</div><div class="line">99</div><div class="line">100</div><div class="line">101</div><div class="line">102</div><div class="line">103</div><div class="line">104</div><div class="line">105</div><div class="line">106</div><div class="line">107</div><div class="line">108</div><div class="line">109</div><div class="line">110</div><div class="line">111</div><div class="line">112</div><div class="line">113</div><div class="line">114</div><div class="line">115</div><div class="line">116</div><div class="line">117</div><div class="line">118</div><div class="line">119</div></pre></td><td class="code"><pre><div class="line">func chanrecv(t *chantype, c *hchan, ep unsafe.Pointer, block bool) (selected, received bool) &#123;</div><div class="line">	// raceenabled: don&apos;t need to check ep, as it is always on the stack</div><div class="line">	// or is new memory allocated by reflect.</div><div class="line"></div><div class="line">	if debugChan &#123;</div><div class="line">		print(&quot;chanrecv: chan=&quot;, c, &quot;\n&quot;)</div><div class="line">	&#125;</div><div class="line"></div><div class="line">	if c == nil &#123;</div><div class="line">		if !block &#123;</div><div class="line">			return</div><div class="line">		&#125;</div><div class="line">		gopark(nil, nil, &quot;chan receive (nil chan)&quot;, traceEvGoStop, 2)</div><div class="line">		throw(&quot;unreachable&quot;)</div><div class="line">	&#125;</div><div class="line"></div><div class="line">	// Fast path: check for failed non-blocking operation without acquiring the lock.</div><div class="line">	//</div><div class="line">	// After observing that the channel is not ready for receiving, we observe that the</div><div class="line">	// channel is not closed. Each of these observations is a single word-sized read</div><div class="line">	// (first c.sendq.first or c.qcount, and second c.closed).</div><div class="line">	// Because a channel cannot be reopened, the later observation of the channel</div><div class="line">	// being not closed implies that it was also not closed at the moment of the</div><div class="line">	// first observation. We behave as if we observed the channel at that moment</div><div class="line">	// and report that the receive cannot proceed.</div><div class="line">	//</div><div class="line">	// The order of operations is important here: reversing the operations can lead to</div><div class="line">	// incorrect behavior when racing with a close.</div><div class="line">	if !block &amp;&amp; (c.dataqsiz == 0 &amp;&amp; c.sendq.first == nil ||</div><div class="line">		c.dataqsiz &gt; 0 &amp;&amp; atomic.Loaduint(&amp;c.qcount) == 0) &amp;&amp;</div><div class="line">		atomic.Load(&amp;c.closed) == 0 &#123;</div><div class="line">		return</div><div class="line">	&#125;</div><div class="line"></div><div class="line">	var t0 int64</div><div class="line">	if blockprofilerate &gt; 0 &#123;</div><div class="line">		t0 = cputicks()</div><div class="line">	&#125;</div><div class="line"></div><div class="line">	lock(&amp;c.lock)</div><div class="line"></div><div class="line">	if c.closed != 0 &amp;&amp; c.qcount == 0 &#123;</div><div class="line">		if raceenabled &#123;</div><div class="line">			raceacquire(unsafe.Pointer(c))</div><div class="line">		&#125;</div><div class="line">		unlock(&amp;c.lock)</div><div class="line">		if ep != nil &#123;</div><div class="line">			typedmemclr(c.elemtype, ep)</div><div class="line">		&#125;</div><div class="line">		return true, false</div><div class="line">	&#125;</div><div class="line"></div><div class="line">	if sg := c.sendq.dequeue(); sg != nil &#123;</div><div class="line">		// Found a waiting sender. If buffer is size 0, receive value</div><div class="line">		// directly from sender. Otherwise, receive from head of queue</div><div class="line">		// and add sender&apos;s value to the tail of the queue (both map to</div><div class="line">		// the same buffer slot because the queue is full).</div><div class="line">		recv(c, sg, ep, func() &#123; unlock(&amp;c.lock) &#125;)</div><div class="line">		return true, true</div><div class="line">	&#125;</div><div class="line"></div><div class="line">	if c.qcount &gt; 0 &#123;</div><div class="line">		// Receive directly from queue</div><div class="line">		qp := chanbuf(c, c.recvx)</div><div class="line">		if raceenabled &#123;</div><div class="line">			raceacquire(qp)</div><div class="line">			racerelease(qp)</div><div class="line">		&#125;</div><div class="line">		if ep != nil &#123;</div><div class="line">			typedmemmove(c.elemtype, ep, qp)</div><div class="line">		&#125;</div><div class="line">		typedmemclr(c.elemtype, qp)</div><div class="line">		c.recvx++</div><div class="line">		if c.recvx == c.dataqsiz &#123;</div><div class="line">			c.recvx = 0</div><div class="line">		&#125;</div><div class="line">		c.qcount--</div><div class="line">		unlock(&amp;c.lock)</div><div class="line">		return true, true</div><div class="line">	&#125;</div><div class="line"></div><div class="line">	if !block &#123;</div><div class="line">		unlock(&amp;c.lock)</div><div class="line">		return false, false</div><div class="line">	&#125;</div><div class="line"></div><div class="line">	// no sender available: block on this channel.</div><div class="line">	gp := getg()</div><div class="line">	mysg := acquireSudog()</div><div class="line">	mysg.releasetime = 0</div><div class="line">	if t0 != 0 &#123;</div><div class="line">		mysg.releasetime = -1</div><div class="line">	&#125;</div><div class="line">	// No stack splits between assigning elem and enqueuing mysg</div><div class="line">	// on gp.waiting where copystack can find it.</div><div class="line">	mysg.elem = ep</div><div class="line">	mysg.waitlink = nil</div><div class="line">	gp.waiting = mysg</div><div class="line">	mysg.g = gp</div><div class="line">	mysg.selectdone = nil</div><div class="line">	mysg.c = c</div><div class="line">	gp.param = nil</div><div class="line">	c.recvq.enqueue(mysg)</div><div class="line">	goparkunlock(&amp;c.lock, &quot;chan receive&quot;, traceEvGoBlockRecv, 3)</div><div class="line"></div><div class="line">	// someone woke us up</div><div class="line">	if mysg != gp.waiting &#123;</div><div class="line">		throw(&quot;G waiting list is corrupted&quot;)</div><div class="line">	&#125;</div><div class="line">	gp.waiting = nil</div><div class="line">	if mysg.releasetime &gt; 0 &#123;</div><div class="line">		blockevent(mysg.releasetime-t0, 2)</div><div class="line">	&#125;</div><div class="line">	closed := gp.param == nil</div><div class="line">	gp.param = nil</div><div class="line">	mysg.c = nil</div><div class="line">	releaseSudog(mysg)</div><div class="line">	return true, !closed</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>接收channel与发送类似首先也是判断channel的类型，然后如果是有缓冲的channel就判断缓冲中是否有元素，接着从channel中获取接受者，如果取到，则直接从接收者获取元素，并唤醒发送者，本次接收过程完成，如果没有取到接收者，阻塞当前的goroutine并等待发送者唤醒，如果是拥有缓冲的channel需要先判断缓冲中是否有元素，缓冲为空时，阻塞当前goroutine并等待发送者唤醒，缓冲如果不为空，则取出缓冲中的第一个元素，然后尝试唤醒channel中的一个发送者(这篇文章暂属临时版本，有些话需要斟酌，不久会更新。。。)</p>
<p>接下来我会发表select的结构先说个预告。。。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">select &#123;</div><div class="line">       case c &lt;- v:</div><div class="line">              ... foo</div><div class="line">       default:</div><div class="line">              ... bar</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>//select的case和default 编译器最终会编译成if else<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">if selectnbsend(c, v) &#123;</div><div class="line">       ... foo</div><div class="line">&#125; else &#123;</div><div class="line">       ... bar</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>未来几天我会完成select的具体实现。。。</p>
]]></content>
      
        
        <tags>
            
            <tag> Go 语言 </tag>
            
            <tag> golang 最佳实践 </tag>
            
            <tag> 技术原理 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[interface引发的事件真相]]></title>
      <url>/2017/10/26/interface%E5%BC%95%E5%8F%91%E7%9A%84%E4%BA%8B%E4%BB%B6%E7%9C%9F%E7%9B%B8/</url>
      <content type="html"><![CDATA[<p><img src="http://oyft9mgwt.bkt.clouddn.com/interface%E5%BC%95%E5%8F%91%E7%9A%84%E4%BA%8B%E4%BB%B6%E7%9C%9F%E7%9B%B8.jpg" alt=""><br>(PS:专栏所有的代码都是基于go version go1.8 darwin/amd64)</p>
<p>流动的水没有形状，漂流的风找不到踪迹，一切代码都了然于心，我们在写代码的时候，总是有一种思维定式陪伴左右，在对事物做判断的时候，往往这种思维定式会往正向或反向做推动作用，在开发的过程中如果不小心忽略，往往就是埋下了陷阱，以下代码是大多数新手会遇到的坑，<br><a id="more"></a></p>
<p>package main</p>
<p>import (<br>    “fmt”<br>)</p>
<p>type People interface {<br>    Name() string<br>}<br>type Student struct{ name string }</p>
<p>func (stu *Student) Name() string {<br>    return stu.name<br>}</p>
<p>func getPeople() People {<br>    var stu *Student<br>    return stu<br>}</p>
<p>func main() {<br>    if getPeople() == nil {<br>        fmt.Println(“AAAAA”)<br>    } else {<br>        fmt.Println(“BBBBB”)<br>    }<br>}<br>上面的代码输出什么那？有些人会认为打印AAAAA，因为他们会认为getPeople方法里面stu是nil 所以返回的就是nil，这样想就大错特错，因为虽然返回的stu是nil 但是函数返回时People接口的结构的本身并不是nil，在我们不了解interface内部结构之前请往下看。</p>
<p>为什么我会选择去写一个关于interface的文章那，我认为他在go语言里面有这非常重要的地位，仅次于goroutine和channel的地位，我在未接触go之前一直从事于c#的开发，接口对我来说就是不同组件之间的契约，对这个契约强制你必须去继承接口，而go语言的设计就非常轻巧，只要实现了接口所要求的所有函数即可，go中的接口分为两种一种是空的接口类似这样：</p>
<p>var in interface{}<br>例外一种是非空的接口即在接口内部声明了一些方法：</p>
<p>type People interface {<br>    Name() string<br>}<br>接下来我就根据上面的例子来对比一下空接口和非空接口内部结构</p>
<p>type eface struct {          //空接口<br>    _type <em>_type         //类型信息<br>    data  unsafe.Pointer //指向数据的指针(go语言中特殊的指针类型unsafe.Pointer类似于c语言中的void</em>)<br>}<br>type iface struct {          //带有方法的接口<br>    tab  <em>itab           //存储type信息还有结构实现方法的集合<br>    data unsafe.Pointer  //指向数据的指针(go语言中特殊的指针类型unsafe.Pointer类似于c语言中的void</em>)<br>}<br>eface包含一个类型信息，可以为reflect提供帮助</p>
<p>type _type struct {<br>    size       uintptr  //类型大小<br>    ptrdata    uintptr  //前缀持有所有指针的内存大小<br>    hash       uint32   //数据hash值<br>    tflag      tflag<br>    align      uint8    //对齐<br>    fieldalign uint8    //嵌入结构体时的对齐<br>    kind       uint8    //kind 有些枚举值kind等于0是无效的<br>    alg        <em>typeAlg //函数指针数组，类型实现的所有方法<br>    gcdata    </em>byte<br>    str       nameOff<br>    ptrToThis typeOff<br>}<br>iface比eface 中间多了一层itab结构</p>
<p>type itab struct {<br>    inter  <em>interfacetype  //接口类型<br>    _type  </em>_type          //结构类型<br>    link   *itab<br>    bad    int32<br>    inhash int32<br>    fun    [1]uintptr      //可变大小 方法集合<br>}<br>itab 存储_type信息和[]fun方法集，从上面的结构我们就可得出，因为data指向了nil 并不代表interface 是nil，所以返回值并不为空，这里的fun(方法集)定义了接口的接收规则，在编译的过程中需要验证是否实现接口，接口的具体细节你可以阅读Go Data Structures: Interfaces </p>
<p>接下来是第二个例子：</p>
<p>package main</p>
<p>import (<br>    “fmt”<br>)</p>
<p>type People interface {<br>    Speak(string) string<br>}</p>
<p>type Stduent struct{}</p>
<p>func (stu *Stduent) Speak(think string) (talk string) {<br>    if think == “bitch” {<br>        talk = “You are a good boy”<br>    } else {<br>        talk = “hi”<br>    }<br>    return<br>}</p>
<p>func main() {<br>    var peo People = Stduent{}<br>    think := “bitch”<br>    fmt.Println(peo.Speak(think))<br>}<br>上面的代码是不能编译过去的，会提示没有实现该接口，只要我们把var peo People = Stduent{}修改为var peo People = &amp;Stduent{}就可以了，为什么会有这种限制，</p>
<p>这是因为接口定义不规定实现者是否应该使用指针接收还是值接收实现接口。当使用接口时，不能保证底层类型是值还是指针。我们上面的例子中，我们定义了指针接受方法，修改为值接受方法:</p>
<p>func (stu Stduent) Speak(think string) (talk string) {<br>    if think == “bitch” {<br>        talk = “You are a good boy”<br>    } else {<br>        talk = “hi”<br>    }<br>    return<br>}<br>我们再次运行打印:</p>
<p>You are a good boy<br>通过上面测试我们得出一个结论使用值传递方法，接口赋值使用var peo People = Stduent{}或者var peo People = &amp;Stduent{}，如果使用指针作为参数传递,则只能使用var peo People = &amp;Stduent{}，正是由于interface的灵活性，可以使用golang实现多态的特性，所以我们更要对interface多做深入了解。(本文未来可能会做一些细微的调整)</p>
]]></content>
      
        
        <tags>
            
            <tag> Go 语言 </tag>
            
            <tag> golang 最佳实践 </tag>
            
            <tag> 编程 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[golang实现epoll代码解析]]></title>
      <url>/2017/10/25/golang%E5%AE%9E%E7%8E%B0epoll%E4%BB%A3%E7%A0%81%E8%A7%A3%E6%9E%90/</url>
      <content type="html"><![CDATA[<p>在文章之前，我先讲个故事，我有个朋友以前是java程序员，后来转过来做go，当我问他为什么选择go的时候，他跟我说，因为写go就没人说他写的代码low了 😄😄😄 这只是个段子不要当真。。。<br>好回归正题 golang 的网络轮循器是如何实现的那，先说明一下 golang 的网络轮循器是做什么的，你的go程序启动的时候会创建一个M去跑我们的系统监测任务代码如下(专栏下面的所有文章都是以go 1.8版本为准):</p>
<a id="more"></a>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">systemstack(func() &#123;</div><div class="line">     newm(sysmon, nil)</div><div class="line">&#125;)</div></pre></td></tr></table></figure>
<p>sysmon方法就是我们说的监控任务，它没有和任何的P(逻辑处理器)进行绑定，而是通过自身改变睡眠时间和时间间隔来一直循环下去(代码位于runtime/proc.go)。 golang中所有文件描述符都被设置成非阻塞的，某个goroutine进行网络io操作，读或者写文件描述符，如果此刻网络io还没准备好，则这个goroutine会被放到系统的等待队列中，这个goroutine失去了运行权，但并不是真正的整个系统“阻塞”于系统调用，后台还有一个poller会不停地进行poll，所有的文件描述符都被添加到了这个poller中的，当某个时刻一个文件描述符准备好了，poller就会唤醒之前因它而阻塞的goroutine，于是goroutine重新运行起来。<br>网络轮循器就在这个for循环之中，从epoll 的epollwait 接口获取准备就绪的 *g (结构指针) 最后注入到当前调度器下的可获取的G队列，代码如下:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">atomic.Cas64(&amp;sched.lastpoll, uint64(lastpoll), uint64(now))</div><div class="line">gp := netpoll(false)</div><div class="line">if gp != nil &#123;</div><div class="line">       injectglist(gp)</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>这里的netpoll就是今天的主角，以下是追踪器的部分代码:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div></pre></td><td class="code"><pre><div class="line">for &#123;</div><div class="line">		if idle == 0 &#123; //20us后开始睡眠</div><div class="line">			delay = 20</div><div class="line">		&#125; else if idle &gt; 50 &#123; //睡眠1毫秒后翻倍</div><div class="line">			delay *= 2</div><div class="line">		&#125;</div><div class="line">		if delay &gt; 10*1000 &#123; //10ms</div><div class="line">			delay = 10 * 1000</div><div class="line">		&#125;</div><div class="line">                //以上是调整时间间隔</div><div class="line">		usleep(delay)</div><div class="line">                //睡眠若干毫秒后,判断是否进行调度追踪，</div><div class="line">                //并且 是否进行垃圾回收或所有的P都处在空闲状态</div><div class="line">		if debug.schedtrace &lt;= 0 &amp;&amp; (sched.gcwaiting != 0 || atomic.Load(&amp;sched.npidle) == uint32(gomaxprocs)) &#123;</div><div class="line">			lock(&amp;sched.lock)</div><div class="line">			if atomic.Load(&amp;sched.gcwaiting) != 0 || atomic.Load(&amp;sched.npidle) == uint32(gomaxprocs) &#123;</div><div class="line">				atomic.Store(&amp;sched.sysmonwait, 1)</div><div class="line">				unlock(&amp;sched.lock)</div><div class="line">				//唤醒任务</div><div class="line">				maxsleep := forcegcperiod / 2</div><div class="line">				if scavengelimit &lt; forcegcperiod &#123;</div><div class="line">					maxsleep = scavengelimit / 2</div><div class="line">				&#125;</div><div class="line">				notetsleep(&amp;sched.sysmonnote, maxsleep)</div><div class="line">				lock(&amp;sched.lock)</div><div class="line"></div><div class="line">				atomic.Store(&amp;sched.sysmonwait, 0)</div><div class="line">				noteclear(&amp;sched.sysmonnote)</div><div class="line">                                //重置时间间隔</div><div class="line">				idle = 0</div><div class="line">				delay = 20</div><div class="line">			&#125;</div><div class="line">			unlock(&amp;sched.lock)</div><div class="line">		&#125;</div><div class="line">		//距离上次拉去是否超过10ms</div><div class="line">		lastpoll := int64(atomic.Load64(&amp;sched.lastpoll))</div><div class="line">		now := nanotime()</div><div class="line">		unixnow := unixnanotime()</div><div class="line">                //判断获取最后一次从网络I/O轮循查找G的时间</div><div class="line">		if lastpoll != 0 &amp;&amp; lastpoll+10*1000*1000 &lt; now &#123;</div><div class="line">                        //更新最后一次查询G时间，为了下一次做判断。</div><div class="line">			atomic.Cas64(&amp;sched.lastpoll, uint64(lastpoll), uint64(now))</div><div class="line">                        //这行代码是今天的主角，从网络I/O(我喜欢叫网络轮询器)</div><div class="line">                        //查找已经就绪的G，注意不是阻塞的</div><div class="line">			gp := netpoll(false)</div><div class="line"></div><div class="line">			if gp != nil &#123;</div><div class="line">				incidlelocked(-1)</div><div class="line">                                //找到后注入到调度器下面的可获取的G队列</div><div class="line">				injectglist(gp)</div><div class="line">				incidlelocked(1)</div><div class="line">			&#125;</div><div class="line">		&#125;</div><div class="line">		// 再次夺取P、 阻塞的系统调用</div><div class="line">		// 再次夺取长时间运行的G</div><div class="line">		...</div><div class="line">                ...</div><div class="line">                ...</div><div class="line">	&#125;</div></pre></td></tr></table></figure>
<p>上面简单的介绍了追踪器的大概流程，接下来有请我们的主角show time.</p>
<p>网络轮轮循器使用I/O多路复用的技术，可以非常高效的处理数以百万计的socket描述符,这里有linux下非阻塞io库 epoll - 知乎专栏的具体介绍。。。</p>
<p>我先列出golang三个封装的系统调用</p>
<h2 id="1、创建epoll"><a href="#1、创建epoll" class="headerlink" title="1、创建epoll"></a>1、创建epoll</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">func epollcreate(size int32) int32</div><div class="line">func epollcreate1(flags int32) int32</div><div class="line"></div><div class="line">TEXT runtime·epollcreate1(SB),NOSPLIT,$0</div><div class="line">	MOVL    $329, AX</div><div class="line">	MOVL	flags+0(FP), BX</div><div class="line">	INVOKE_SYSCALL</div><div class="line">	MOVL	AX, ret+4(FP)</div><div class="line">	RET</div><div class="line">epollcreate() 可以创建一个epoll实例。在linux 内核版本大于2.6.8 后，这个size 参数就被弃用了，但是传入的值必须大于0。这里引用了互联网上的一句话</div></pre></td></tr></table></figure>
<p>在 epollcreate() 的最初实现版本时， size参数的作用是创建epoll实例时候告诉内核需要使用多少个文件描述符。内核会使用 size 的大小去申请对应的内存(如果在使用的时候超过了给定的size， 内核会申请更多的空间)。现在，这个size参数不再使用了（内核会动态的申请需要的内存）。但要注意的是，这个size必须要大于0，为了兼容旧版的linux 内核的代码。<br>epollcreate1() 如果flags的值是0，epollcreate1()等同于epollcreate()除了过时的size被遗弃了。当然flasg可以使用_EPOLL_CLOEXEC = 0x80000。</p>
<h2 id="2、设置epoll事件"><a href="#2、设置epoll事件" class="headerlink" title="2、设置epoll事件"></a>2、设置epoll事件</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">func epollctl(epfd, op, fd int32, ev *epollevent) int32</div><div class="line"></div><div class="line">// sys_linux_386.s</div><div class="line">TEXT runtime·epollctl(SB),NOSPLIT,$0</div><div class="line">	MOVL	$255, AX</div><div class="line">	MOVL	epfd+0(FP), BX</div><div class="line">	MOVL	op+4(FP), CX</div><div class="line">	MOVL	fd+8(FP), DX</div><div class="line">	MOVL	ev+12(FP), SI</div><div class="line">	INVOKE_SYSCALL</div><div class="line">	MOVL	AX, ret+16(FP)</div><div class="line">	RET</div></pre></td></tr></table></figure>
<p>第一个参数epfd指向epoll的实例，op 添加事件的类型 fd是要注册的目标文件描述符，ev 是关联指定的描述符</p>
<p>op 的枚举值:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">_EPOLL_CTL_ADD = 0x1 //在epfd中注册指定的fd文件描述符并能把event和fd关联起来。</div><div class="line">_EPOLL_CTL_MOD = 0x3 //改变 fd和evetn之间的联系。</div><div class="line">_EPOLL_CTL_DEL = 0x2 //从指定的epfd中删除fd文件描述符。在这种模式中event是被忽略的，并且为可以等于nil。</div></pre></td></tr></table></figure>
<p>event 结构</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">type epollevent struct &#123;</div><div class="line">	events uint32</div><div class="line">	data   [8]byte // to match amd64</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h2 id="3、等待epoll事件"><a href="#3、等待epoll事件" class="headerlink" title="3、等待epoll事件"></a>3、等待epoll事件</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">func epollwait(epfd int32, ev *epollevent, nev, timeout int32) int32</div><div class="line"></div><div class="line">TEXT runtime·epollwait(SB),NOSPLIT,$0</div><div class="line">	MOVL	$256, AX</div><div class="line">	MOVL	epfd+0(FP), BX</div><div class="line">	MOVL	ev+4(FP), CX</div><div class="line">	MOVL	nev+8(FP), DX</div><div class="line">	MOVL	timeout+12(FP), SI</div><div class="line">	INVOKE_SYSCALL</div><div class="line">	MOVL	AX, ret+16(FP)</div><div class="line">	RET</div></pre></td></tr></table></figure>
<p>epollwait 这个系统调用是用来返回epfd中的就绪的G。events指向调用者可以使用的事件的内存区域。nev告知内核有多少个events，必须要大于0，timeout 指定超时时间。</p>
<p>golang 网络轮循器的代码实现</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div></pre></td><td class="code"><pre><div class="line">func netpoll(block bool) *g &#123;</div><div class="line">	if epfd == -1 &#123;</div><div class="line">		return nil</div><div class="line">	&#125;</div><div class="line">	waitms := int32(-1)</div><div class="line">	if !block &#123;</div><div class="line">		waitms = 0</div><div class="line">	&#125;</div><div class="line">	var events [128]epollevent</div><div class="line">retry:</div><div class="line">	n := epollwait(epfd, &amp;events[0], int32(len(events)), waitms)</div><div class="line">	if n &lt; 0 &#123;</div><div class="line">		if n != -_EINTR &#123;</div><div class="line">			println(&quot;runtime: epollwait on fd&quot;, epfd, &quot;failed with&quot;, -n)</div><div class="line">			throw(&quot;epollwait failed&quot;)</div><div class="line">		&#125;</div><div class="line">		goto retry</div><div class="line">	&#125;</div><div class="line">	var gp guintptr</div><div class="line">	for i := int32(0); i &lt; n; i++ &#123;</div><div class="line">		ev := &amp;events[i]</div><div class="line">		if ev.events == 0 &#123;</div><div class="line">			continue</div><div class="line">		&#125;</div><div class="line">		var mode int32</div><div class="line">		if ev.events&amp;(_EPOLLIN|_EPOLLRDHUP|_EPOLLHUP|_EPOLLERR) != 0 &#123;</div><div class="line">			mode += &apos;r&apos;</div><div class="line">		&#125;</div><div class="line">		if ev.events&amp;(_EPOLLOUT|_EPOLLHUP|_EPOLLERR) != 0 &#123;</div><div class="line">			mode += &apos;w&apos;</div><div class="line">		&#125;</div><div class="line">		if mode != 0 &#123;</div><div class="line">			pd := *(**pollDesc)(unsafe.Pointer(&amp;ev.data))</div><div class="line"></div><div class="line">			netpollready(&amp;gp, pd, mode)</div><div class="line">		&#125;</div><div class="line">	&#125;</div><div class="line">	if block &amp;&amp; gp == 0 &#123;</div><div class="line">		goto retry</div><div class="line">	&#125;</div><div class="line">	return gp.ptr()</div><div class="line">&#125;</div></pre></td></tr></table></figure>
]]></content>
      
        
        <tags>
            
            <tag> epoll </tag>
            
            <tag> IO多路复用 </tag>
            
            <tag> Go语言 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[linux下非阻塞io库 epoll]]></title>
      <url>/2017/10/25/linux%E4%B8%8B%E9%9D%9E%E9%98%BB%E5%A1%9Eio%E5%BA%93-epoll/</url>
      <content type="html"><![CDATA[<h2 id="一、用一个生活中的例子来解释"><a href="#一、用一个生活中的例子来解释" class="headerlink" title="一、用一个生活中的例子来解释."></a>一、用一个生活中的例子来解释.</h2><p>假设你在大学中读书,要等待一个朋友来访,而这个朋友只知道你在A号楼,但是不知道你具体住在哪里,于是你们约好了在A号楼门口见面.<br>如果你使用的阻塞IO模型来处理这个问题,那么你就只能一直守候在A号楼门口等待朋友的到来,在这段时间里你不能做别的事情,不难知道,这种方式的效率是低下的.</p>
<p>进一步解释select和epoll模型的差异.<br>select版大妈做的是如下的事情:比如同学甲的朋友来了,select版大妈比较笨,她带着朋友挨个房间进行查询谁是同学甲,你等的朋友来了,于是在实际的代码中,select版大妈做的是以下的事情:</p>
<a id="more"></a>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">int n = select(&amp;readset,NULL,NULL,100); </div><div class="line">for (int i = 0; n &gt; 0; ++i) &#123;</div><div class="line">     if (FD_ISSET(fdarray[i], &amp;readset)) &#123;</div><div class="line">         do_something(fdarray[i]); --n; </div><div class="line">    &#125; </div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>epoll版大妈就比较先进了,她记下了同学甲的信息,比如说他的房间号,那么等同学甲的朋友到来时,只需要告诉该朋友同学甲在哪个房间即可,不用自己亲自带着人满大楼的找人了.于是epoll版大妈做的事情可以用如下的代码表示:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">n = epoll_wait(epfd,events,20,500);</div><div class="line">for(i=0;i&lt;n;++i) &#123; </div><div class="line">    do_something(events[n]);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>在epoll中,关键的数据结构epoll_event定义如下:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">typedef union epoll_data &#123;</div><div class="line">     void *ptr;</div><div class="line">     int fd; </div><div class="line">     __uint32_t u32;</div><div class="line">     __uint64_t u64; </div><div class="line">&#125;epoll_data_t; </div><div class="line"></div><div class="line">struct epoll_event &#123; </div><div class="line">    __uint32_t events; /* Epoll events */ </div><div class="line">    epoll_data_t data;/* User data variable */</div><div class="line"> &#125;;</div></pre></td></tr></table></figure></p>
<p>可以看到,epoll_data是一个union结构体,它就是epoll版大妈用于保存同学信息的结构体,它可以保存很多类型的信息:<br>fd,指针,等等.有了这个结构体,epoll大妈可以不用吹灰之力就可以定位到同学甲.</p>
<p>别小看了这些效率的提高,在一个大规模并发的服务器中,轮询IO是最耗时间的操作之一.再回到那个例子中,如果每到来一个朋友楼管大妈都要全楼的查询同学,那么处理的效率必然就低下了,过不久楼底就有不少的人了.</p>
<p>对比最早给出的阻塞IO的处理模型, 可以看到采用了多路复用IO之后, 程序可以自由的进行自己除了IO操作之外的工作, 只有到IO状态发生变化的时候由多路复用IO进行通知, 然后再采取相应的操作, 而不用一直阻塞等待IO状态发生变化了.</p>
<p>从上面的分析也可以看出,epoll比select的提高实际上是一个用空间换时间思想的具体应用.</p>
<h2 id="二、深入理解epoll的实现原理：开发高性能网络程序时，windows开发者们言必称iocp，linux开发者们则言必称epoll。"><a href="#二、深入理解epoll的实现原理：开发高性能网络程序时，windows开发者们言必称iocp，linux开发者们则言必称epoll。" class="headerlink" title="二、深入理解epoll的实现原理：开发高性能网络程序时，windows开发者们言必称iocp，linux开发者们则言必称epoll。"></a>二、深入理解epoll的实现原理：开发高性能网络程序时，windows开发者们言必称iocp，linux开发者们则言必称epoll。</h2><p>大家都明白epoll是一种IO多路复用技术，可以非常高效的处理数以百万计的socket句柄，比起以前的select和poll效率高大发了。</p>
<p>我们用起epoll来都感觉挺爽，确实快，那么，它到底为什么可以高速处理这么多并发连接呢？</p>
<p>先简单回顾下如何使用C库封装的3个epoll系统调用吧。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">int epoll_create(int size); </div><div class="line">int epoll_ctl(int epfd, int op, int fd, struct epoll_event *event); </div><div class="line">int epoll_wait(int epfd, struct epoll_event *events,int maxevents, int timeout);</div></pre></td></tr></table></figure>
<p>使用起来很清晰，首先要调用epoll_create建立一个epoll对象。参数size是内核保证能够正确处理的最大句柄数，多于这个最大数时内核可不保证效果。<br>epoll_ctl可以操作上面建立的epoll，例如，将刚建立的socket加入到epoll中让其监控，或者把 epoll正在监控的某个socket句柄移出epoll，不再监控它等等。</p>
<p>epoll_wait在调用时，在给定的timeout时间内，当在监控的所有句柄中有事件发生时，就返回用户态的进程。<br>从上面的调用方式就可以看到epoll比select/poll的优越之处：</p>
<p>因为后者每次调用时都要传递你所要监控的所有socket给select/poll系统调用，这意味着需要将用户态的socket列表copy到内核态，如果以万计的句柄会导致每次都要copy几十几百KB的内存到内核态，非常低效。</p>
<p>而我们调用epoll_wait时就相当于以往调用select/poll，但是这时却不用传递socket句柄给内核，因为内核已经在epoll_ctl中拿到了要监控的句柄列表。</p>
<p>所以，实际上在你调用epoll_create后，内核就已经在内核态开始准备帮你存储要监控的句柄了，每次调用epoll_ctl只是在往内核的数据结构里塞入新的socket句柄。</p>
<p>在内核里，一切皆文件。所以，epoll向内核注册了一个文件系统，用于存储上述的被监控socket。</p>
<p>当你调用epoll_create时，就会在这个虚拟的epoll文件系统里创建一个file结点。当然这个file不是普通文件，它只服务于epoll。epoll在被内核初始化时（操作系统启动），同时会开辟出epoll自己的内核高速cache区，用于安置每一个我们想监控的socket，这些socket会以红黑树的形式保存在内核cache里，以支持快速的查找、插入、删除。</p>
<p>这个内核高速cache区，就是建立连续的物理内存页，然后在之上建立slab层，简单的说，就是物理上分配好你想要的size的内存对象，每次使用时都是使用空闲的已分配好的对象。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">static int __init eventpoll_init(void) &#123; </div><div class="line">    ... ... </div><div class="line">    /* Allocates slab cache used to allocate &quot;struct epitem&quot; items */ </div><div class="line">    epi_cache = kmem_cache_create(&quot;eventpoll_epi&quot;, sizeof(struct  epitem),0,SLAB_HWCACHE_ALIGN| EPI_SLAB_DEBUG|SLAB_PANIC, NULL, NULL); </div><div class="line">    /* Allocates slab cache used to allocate &quot;struct eppoll_entry&quot; */ </div><div class="line">    pwq_cache = kmem_cache_create(&quot;eventpoll_pwq&quot;, sizeof(struct eppoll_entry), 0, EPI_SLAB_DEBUG|SLAB_PANIC, NULL, NULL); </div><div class="line">    ... ...</div></pre></td></tr></table></figure>
<p>epoll的高效就在于，当我们调用epoll_ctl往里塞入百万个句柄时，epoll_wait仍然可以飞快的返回，并有效的将发生事件的句柄给我们用户。</p>
<p>这是由于我们在调用epoll_create时，内核除了帮我们在epoll文件系统里建了个file结点，在内核cache里建了个红黑树用于存储以后epoll_ctl传来的socket外，还会再建立一个list链表，用于存储准备就绪的事件，当epoll_wait调用时，仅仅观察这个list链表里有没有数据即可。有数据就返回，没有数据就sleep，等到timeout时间到后即使链表没数据也返回。所以，epoll_wait非常高效。</p>
<p>那么，这个准备就绪list链表是怎么维护的呢？当我们执行epoll_ctl时，除了把socket放到epoll文件系统里file对象对应的红黑树上之外，还会给内核中断处理程序注册一个回调函数，告诉内核，如果这个句柄的中断到了，就把它放到准备就绪list链表里。</p>
<p>所以，当一个socket上有数据到了，内核在把网卡上的数据copy到内核中后就来把socket插入到准备就绪链表里了。<br>如此，一颗红黑树，一张准备就绪句柄链表，少量的内核cache，就帮我们解决了大并发下的socket处理问题。</p>
<p>执行epoll_create时，创建了红黑树和就绪链表，执行epoll_ctl时，如果增加socket句柄，则检查在红黑树中是否存在，存在立即返回，不存在则添加到树干上，然后向内核注册回调函数，用于当中断事件来临时向准备就绪链表中插入数据。执行epoll_wait时立刻返回准备就绪链表里的数据即可。</p>
<p>最后看看epoll独有的两种模式LT和ET。无论是LT和ET模式，都适用于以上所说的流程。</p>
<p>区别是，LT模式下，只要一个句柄上的事件一次没有处理完，会在以后调用epoll_wait时次次返回这个句柄，而ET模式仅在第一次返回。</p>
<p>这件事怎么做到的呢？当一个socket句柄上有事件时，内核会把该句柄插入上面所说的准备就绪list链表，这时我们调用epoll_wait，会把准备就绪的socket拷贝到用户态内存，然后清空准备就绪list链表，最后，epoll_wait干了件事，就是检查这些socket，如果不是ET模式（就是LT模式的句柄了），并且这些socket上确实有未处理的事件时，又把该句柄放回到刚刚清空的准备就绪链表了。</p>
<p>所以，非ET的句柄，只要它上面还有事件，epoll_wait每次都会返回。而ET模式的句柄，除非有新中断到，即使socket上的事件没有处理完，也是不会次次从epoll_wait返回的。</p>
<h2 id="三、扩展阅读（epoll与之前其他相关技术的比较）："><a href="#三、扩展阅读（epoll与之前其他相关技术的比较）：" class="headerlink" title="三、扩展阅读（epoll与之前其他相关技术的比较）："></a>三、扩展阅读（epoll与之前其他相关技术的比较）：</h2><p>Linux提供了select、poll、epoll接口来实现IO复用，三者的原型如下所示，本文从参数、实现、性能等方面对三者进行对比。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">int select(int nfds, fd_set *readfds, fd_set *writefds, fd_set *exceptfds, struct timeval *timeout); </div><div class="line">int poll(struct pollfd *fds, nfds_t nfds, int timeout);</div><div class="line">int epoll_wait(int epfd, struct epoll_event *events, int maxevents, int timeout);</div></pre></td></tr></table></figure>
<p>select、poll、epoll_wait参数及实现对比</p>
<p>select的第一个参数nfds为fdset集合中最大描述符值加1，fdset是一个位数组，其大小限制为__FD_SETSIZE（1024），位数组的每一位代表其对应的描述符是否需要被检查。<br>select的第二三四个参数表示需要关注读、写、错误事件的文件描述符位数组，这些参数既是输入参数也是输出参数，可能会被内核修改用于标示哪些描述符上发生了关注的事件。<br>所以每次调用select前都需要重新初始化fdset。<br>timeout参数为超时时间，该结构会被内核修改，其值为超时剩余的时间。<br>select对应于内核中的sys_select调用，sys_select首先将第二三四个参数指向的fd_set拷贝到内核，然后对每个被SET的描述符调用进行poll，并记录在临时结果中（fdset），如果有事件发生，select会将临时结果写到用户空间并返回；当轮询一遍后没有任何事件发生时，如果指定了超时时间，则select会睡眠到超时，睡眠结束后再进行一次轮询，并将临时结果写到用户空间，然后返回。 select返回后，需要逐一检查关注的描述符是否被SET（事件是否发生）。</p>
<p>poll与select不同，通过一个pollfd数组向内核传递需要关注的事件，故没有描述符个数的限制，pollfd中的events字段和revents分别用于标示关注的事件和发生的事件，故pollfd数组只需要被初始化一次。<br>poll的实现机制与select类似，其对应内核中的sys_poll，只不过poll向内核传递pollfd数组，然后对pollfd中的每个描述符进行poll，相比处理fdset来说，poll效率更高。 poll返回后，需要对pollfd中的每个元素检查其revents值，来得指事件是否发生。</p>
<p>epoll通过epoll_create创建一个用于epoll轮询的描述符，通过epoll_ctl添加/修改/删除事件，通过epoll_wait检查事件，epoll_wait的第二个参数用于存放结果。 epoll与select、poll不同，首先，其不用每次调用都向内核拷贝事件描述信息，在第一次调用后，事件信息就会与对应的epoll描述符关联起来。另外epoll不是通过轮询，而是通过在等待的描述符上注册回调函数，当事件发生时，回调函数负责把发生的事件存储在就绪事件链表中，最后写到用户空间。</p>
]]></content>
      
        
        <tags>
            
            <tag> epoll </tag>
            
            <tag> IO多路复用 </tag>
            
            <tag> Go语言 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[我的第一篇博客]]></title>
      <url>/2017/10/25/%E6%88%91%E7%9A%84%E7%AC%AC%E4%B8%80%E7%AF%87%E5%8D%9A%E5%AE%A2/</url>
      <content type="html"><![CDATA[<p>#这是我的第一篇博客</p>
<p>推荐一下我的专栏: <a href="https://zhuanlan.zhihu.com/goroutine" target="_blank" rel="external">golang数据结构内部实现</a></p>
]]></content>
      
        
    </entry>
    
  
  
</search>
